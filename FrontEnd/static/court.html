<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GOB Court Animation Test</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #222;
    }

    canvas {
      display: block;
      background-color: transparent;
    }

    #court {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
    }

    #gameLayer {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }
  </style>
</head>
<body>
  <img id="court" width="1229" height="768" />
  <canvas id="gameLayer" width="1229" height="768"></canvas>

  <script>
    const canvas = document.getElementById('gameLayer');
    const ctx = canvas.getContext('2d');
    
    let animationStartTime = null;
    let currentTurn = null; // array of 10 player animation objects

    const HCO_STRING_SPOTS = {
        "key": {"x": 64, "y": 25},
        "upper midWing": {"x": 68, "y": 36}, 
        "lower midWing": {"x": 68, "y": 14},
        "upper wing": {"x": 73, "y": 40}, 
        "lower wing": {"x": 73, "y": 10},
        "upper midCorner": {"x": 81, "y": 43}, 
        "lower midCorner": {"x": 81, "y": 7},
        "upper corner": {"x": 88, "y": 44}, 
        "lower corner": {"x": 88, "y": 6},
        "upper highPost": {"x": 74, "y": 32}, 
        "lower highPost": {"x": 74, "y": 19},
        "upper midPost": {"x": 80, "y": 32}, 
        "lower midPost": {"x": 80, "y": 19},
        "upper lowPost": {"x": 86, "y": 32}, 
        "lower lowPost": {"x": 86, "y": 19}, 
        "topLane": {"x": 74, "y": 25},
        "midLane": {"x": 80, "y": 25}, 
        "upper apex": {"x": 80, "y": 36}, 
        "lower apex": {"x": 80, "y": 15},
        "upper midBaseline": {"x": 89, "y": 36}, 
        "lower midBaseline": {"x": 89, "y": 15},
    }

    function getPlayerColors(playerId, homeTeam, awayTeam) {
      const isHome = homeTeam.player_ids.includes(playerId);
      const team = isHome ? homeTeam : awayTeam;

      if (isHome) {
        return {
          fill: team.primary_color,
          stroke: team.secondary_color,
          text: team.secondary_color,
          textAlign: "top"
        };
      } else {
        return {
          fill: "#ffffff",
          stroke: team.primary_color,
          text: team.primary_color,
          textAlign: "bottom"
        };
      }
    }


    function startAnimation(turn) {
      animationStartTime = performance.now();
      currentTurn = turn;
    }

    function gridToPixels(x, y) {
      const pixelX = (x / 100) * 1229;
      const pixelY = ((50 - y) / 50) * 768;
      return { x: pixelX, y: pixelY };
    }
    function drawPlayer(player, coords) {
      if (!window.teamInfo || !teamInfo.home || !teamInfo.away) return;

      const { fill, stroke, text, textAlign } = getPlayerColors(player.playerId, teamInfo.home, teamInfo.away);
      console.log(`Draw ${player.pos || "??"} with fill: ${fill}, text: ${text}, stroke: ${stroke}`);
      console.log("Draw", player.playerId, "pos:", player.pos, "jersey:", player.jersey);

      const radius = 20;
      const x = coords.x;
      const y = coords.y;

      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fillStyle = fill;
      ctx.strokeStyle = stroke;
      ctx.lineWidth = 3;
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = text;
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = textAlign === "top" ? "top" : "bottom";
      const posLabel = playerPositions[player.playerId] || "HH";
      ctx.fillText(posLabel, x, y + (textAlign === "top" ? -radius - 5 : radius + 5));  
      // ctx.fillText(player.pos || "", x, y + (textAlign === "top" ? -radius - 5 : radius + 5));
      ctx.font = 'bold 12px Arial';
      ctx.fillText(player.jersey || "", x, y + (textAlign === "top" ? -radius - 20 : radius + 20));
    }

    let playerStates = {}; 
    let players = [];
    let homeColors = {};
    let awayColors = {};
    let playerPositions = {};

    async function loadSimAndStart() {
      try {
        const res = await fetch("/simulate", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            home_team: "Four Corners",
            away_team: "Bentley-Truman"
          })
        });
        console.log("üöÄ loadSimAndStart() is running -- CONFIRMEE!!!!");

        if (!res.ok) throw new Error(`Simulation failed: ${res.statusText}`);

        const simData = await res.json(); // getting all sim data here
        console.log("‚úÖ Sim data loaded:", simData);
        // Build playerId -> position map from first turn's lineups
        const firstTurn = simData.turns[0] || {};
        const homeLineup = firstTurn.home_lineup || {};
        const awayLineup = firstTurn.away_lineup || {};

        for (const [pos, player] of Object.entries(homeLineup)) {
          if (player && player.playerId) {
            playerPositions[player.playerId] = pos;
          }
        }
        for (const [pos, player] of Object.entries(awayLineup)) {
          if (player && player.playerId) {
            playerPositions[player.playerId] = pos;
          }
        }
        console.log("üìå playerPositions:", playerPositions);

        
        simData.turns.forEach(turn => {
          turn.animations = turn.animations.map(anim => {
            const fullPlayer = simData.players.find(p => p.playerId === anim.playerId);
            return {
              ...anim,
              ...fullPlayer
            };
          });
        });

        homeColors = simData.home_team_colors;
        awayColors = simData.away_team_colors;
        console.log("üè† Home colors:", homeColors);
        console.log("üõ´ Away colors:", awayColors);
        teamInfo = {
          home: {
            player_ids: simData.players.filter(p => p.team === 'home').map(p => p.playerId),
            primary_color: simData.home_team_colors.primary_color,
            secondary_color: simData.home_team_colors.secondary_color
          },
          away: {
            player_ids: simData.players.filter(p => p.team === 'away').map(p => p.playerId),
            primary_color: simData.away_team_colors.primary_color,
            secondary_color: simData.away_team_colors.secondary_color
          }
        };


        // Dynamically load court image based on home_team_id
        const courtImg = document.getElementById("court");
        if (simData.home_team_id) {
          const teamId = simData.home_team_id.toLowerCase();
          courtImg.src = `/static/images/courts/${teamId}.jpg`;

          // Optional fallback in case the image doesn't exist
          courtImg.onerror = () => {
            console.warn(`‚ö†Ô∏è Court image not found for ${teamId}, using fallback.`);
            courtImg.src = "/static/images/courts/default.jpg";
          };
        }

        players = simData.players || [];
        console.log("üîç Players loaded:", players);
        playTurns(simData.turns);
      } catch (err) {
        console.error("‚ùå Simulation failed:", err);
      }
    }
    function getMaxTurnDuration(turn) {
      return Math.max(...turn.map(p => p.movement?.at(-1)?.timestamp || 0));
    }


    function playTurns(turns) {
      let currentTurnIndex = 0;

      function playNextTurn() {
        if (currentTurnIndex >= turns.length) {
          console.log("‚úÖ All turns finished!");
          return;
        }

        const turn = turns[currentTurnIndex];
        const animationQueue = turn.animations || [];
        const playerPositions = {};

        // Extract from home lineup
        Object.entries(turn.home_lineup || {}).forEach(([pos, playerId]) => {
          playerPositions[playerId] = pos;
        });

        // Extract from away lineup
        Object.entries(turn.away_lineup || {}).forEach(([pos, playerId]) => {
          playerPositions[playerId] = pos;
        });

        console.log(`‚ñ∂Ô∏è Playing turn ${currentTurnIndex + 1}/${turns.length}`, turn);

        playerStates = {};
        animationQueue.forEach(anim => {
          playerStates[anim.playerId] = {
            ...anim,
            startTime: performance.now()
          };
        });

        const maxDuration = Math.max(...animationQueue.map(a => a.duration || 600), 600);

        // ‚úÖ Fix: Set currentTurn for animation use
        currentTurn = animationQueue;
        animationStartTime = performance.now();

        requestAnimationFrame(function animateTurnFrame(currentTime) {
          const elapsed = currentTime - animationStartTime;

          ctx.clearRect(0, 0, canvas.width, canvas.height);

          currentTurn.forEach(player => {
            const movement = player.movement;
            if (!movement || movement.length < 2) {
              drawPlayer(player, player.start || { x: 64, y: 25 });
              return;
            }

            console.log(`Player ${player.pos} movement:`, player.movement);
            // if (!movement || movement.length < 2) return;

            let stepIndex = 0;
            while (
              stepIndex < movement.length - 1 &&
              elapsed >= movement[stepIndex + 1].timestamp
            ) {
              stepIndex++;
            }

            const currStep = movement[stepIndex];
            const nextStep = movement[stepIndex + 1] || currStep;

            const progress = nextStep.timestamp === currStep.timestamp
              ? 1
              : (elapsed - currStep.timestamp) / (nextStep.timestamp - currStep.timestamp);

            console.log(`üèÄ ${player.playerId} moving from ${currStep.spot} to ${nextStep.spot}`);
            console.log(`Spot: "${currStep.spot}" ‚Üí`, HCO_STRING_SPOTS[currStep.spot]);
            console.log(`Next spot: "${nextStep.spot}" ‚Üí`, HCO_STRING_SPOTS[nextStep.spot]);

            const coordA = HCO_STRING_SPOTS[currStep.spot] || player.start || { x: 64, y: 25 };
            const coordB = HCO_STRING_SPOTS[nextStep.spot] || player.end || coordA;


            const x = coordA.x + (coordB.x - coordA.x) * progress;
            const y = coordA.y + (coordB.y - coordA.y) * progress;

            drawPlayer(player, { x, y });
          });

          if (elapsed < getMaxTurnDuration(currentTurn)) {
            requestAnimationFrame(animateTurnFrame);
          }
        });

        setTimeout(() => {
          currentTurnIndex++;
          playNextTurn();
        }, maxDuration + 100);
      }

      playNextTurn();
    }

    loadSimAndStart();
  </script>
</body>
</html>
